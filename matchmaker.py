#! /bin/python3.8

import sqlite3 as sql
from dataclasses import dataclass
import itertools as it
import math


BASE_ELO = 1000 # Base Elo
PPM = 7 # Points Per Match
K = 16 # K factor in elo rating

@dataclass
class Team:
    code: int
    name: str
    elo: float

    def expected_score(self, other) -> float:
        return round((1 / ( 1 + 10**((other.elo - self.elo)/400))) * PPM, 2)

    def pretty(self) -> str:
        return f"{self.name}({self.elo})"
    def __hash__(self):
        # Codes are unique and generated by the database
        return hash(self.code)

@dataclass
class Match:
    turn: int
    team1: Team
    team2: Team

    def utility(self) -> float:
        escore1 = self.team1.expected_score(self.team2)
        escore2 = self.team2.expected_score(self.team1)
        distance = math.exp(-abs(escore1 - escore2))
        return distance
    
    def pretty(self) -> str:
        e1 = self.team1.expected_score(self.team2)
        e2 = self.team2.expected_score(self.team1)
        t1_elo = round(self.team1.elo, 2)
        t2_elo = round(self.team2.elo, 2)
        return f"{self.team1.name}({t1_elo}) VS {self.team2.name}({t2_elo}) ~ {e1}-{e2}"

    def __hash__(self):
        return hash(self.team1.code) & hash(self.team2.code)
    def __eq__(self, other):
        return (self.team1.code in (other.team1.code, other.team2.code)
                and self.team2.code in (other.team1.code, other.team2.code))
    def __gt__(self, other):
        return self.utility() > other.utility()
    def __ge__(self, other):
        return self.utility() >= other.utility()
    def __lt__(self, other):
        return self.utility() < other.utility()
    def __le__(self, other):
        return self.utility() <= other.utility()

@dataclass(repr=False)
class Set:
    matches: (Match, Match, Match, Match)

    def utility(self):
        return sum(map(lambda x: x.utility(), self.matches))
    def __repr__(self):
        return repr(list(map(lambda x: (x.team1.name, x.team2.name), self.matches)))
    def __gt__(self, other):
        return self.utility() > other.utility()
    def __ge__(self, other):
        return self.utility() >= other.utility()
    def __lt__(self, other):
        return self.utility() < other.utility()
    def __le__(self, other):
        return self.utility() <= other.utility()

PREV_MATCHES = set()
def load_previous_matches(conn, turn):
    global PREV_MATCHES
    query = f"""
        SELECT result.turn, result.team1, team1.name, result.team2, team2.name
        FROM result
        INNER JOIN team as team1 ON result.team1 = team1.code
        INNER JOIN team as team2 ON result.team2 = team2.code
        WHERE turn < {turn}
    """
    PREV_MATCHES = {
        Match(turn, Team(id1, n1, 0), Team(id2, n2, 0))
        for (turn, id1, n1, id2, n2) in conn.execute(query).fetchall()
    }

def make_matches(turn, teams):
    def appear_once(matches) -> bool:
        teams = set()
        for match in matches:
            team1 = match.team1
            team2 = match.team2
            if team1 in teams or team2 in teams:
                return False
            teams.add(team1)
            teams.add(team2)
        return True
    p_matches = { Match(turn, *teams) for teams in it.combinations(teams, 2) }
    p_matches.difference_update(PREV_MATCHES)
    p_sets = [ Set(matches) for matches in it.combinations(p_matches, 4) if appear_once(matches) ]
    return max(p_sets).matches

def main(conn, turn):
    if turn == 1:
        # Le premier round est aléatoire
        import random
        rteams =  [Team(*x, elo=BASE_ELO) for x in conn.execute("SELECT * FROM team").fetchall()]
        random.shuffle(rteams)
        matches = [Match(turn, *rteams[i:i+2]) for i in range(0, len(rteams), 2)]

    else:
        # Les rounds d'après sont determinés par l'algorithme.
        # Pour cela on calcul l'état du monde (l'elo actuel des équipes)
        # avec les données de l'état d'avant.
        query = f"""
            SELECT result.team1, team1.name, result.elo1, result.points1,
                   result.team2, team2.name, result.elo2, result.points2 
            FROM result
            INNER JOIN team as team1 ON result.team1 = team1.code
            INNER JOIN team as team2 ON result.team2 = team2.code
            WHERE turn = {turn-1}
        """
        teams = []
        for match in conn.execute(query).fetchall():
            t1 = Team(*match[:3])
            score1 = match[3]
            
            t2 = Team(*match[4:7])
            score2 = match[7]
            
            # update to current state of the world
            t1_ed = K * (score1 - t1.expected_score(t2))
            t2.elo += K * (score2 - t2.expected_score(t1))
            t1.elo += t1_ed

            teams.append(t1)
            teams.append(t2)
        load_previous_matches(conn, turn)
        matches = make_matches(turn, teams)

    for match in matches:
        print(match.pretty())
    return

if __name__ == "__main__":
    import argparse as ap
    def parser() -> ap.ArgumentParser:
        parser = ap.ArgumentParser(description = "Add values to the database")
        parser.add_argument("turn", type=int)
        return parser
    args = parser().parse_args()
    with sql.connect("db.sqlite3") as conn:
        main(conn, args.turn)
