#! /bin/python3.8

""" generate pairs for the next turn of the db """

import sqlite3 as sql
from dataclasses import dataclass
import itertools as it
import math


BASE_ELO = 1000 # Base Elo
PPM = 7 # Points Per Match
K = 16 # K factor in elo rating

T = 3
D = 0.2

@dataclass
class Team:
    """ Abstraction of the team table """
    code: int
    name: str
    elo: float

    def expected_score(self, other) -> float:
        """ compute expected score according to the elo formula """
        return round((1 / ( 1 + 10**((other.elo - self.elo)/400))) * PPM, 2)

    def pretty(self) -> str:
        """ pretty print the class """
        return f"{self.name}({self.elo})"
    def __hash__(self):
        # Codes are unique and generated by the database
        return hash(self.code)

@dataclass
class Match:
    """ A match is a pair of teams at a fixed turn """
    turn: int
    team1: Team
    team2: Team

    def utility(self) -> float:
        """ compute principal's utility of the match """
        escore1 = self.team1.expected_score(self.team2)
        escore2 = self.team2.expected_score(self.team1)
        distance = math.exp(-abs(escore1 - escore2)) # ]0; 1[
        return distance + (self.period() / distance) # ]0; +inf[

    def period(self) -> float:
        """ compute periodic factor for the turn: {0, 1} """
        turn = self.turn * 100
        return max((-1) ** int((turn % T)/T >= D), 0)

    def pretty(self) -> str:
        """ pretty print the class """
        exp1 = self.team1.expected_score(self.team2)
        exp2 = self.team2.expected_score(self.team1)
        t1_elo = round(self.team1.elo, 2)
        t2_elo = round(self.team2.elo, 2)
        return f"{self.team1.name}({t1_elo}) VS {self.team2.name}({t2_elo}) ~ {exp1}-{exp2}"

    def __hash__(self):
        return hash(self.team1.code) & hash(self.team2.code)
    def __eq__(self, other):
        return (self.team1.code in (other.team1.code, other.team2.code)
                and self.team2.code in (other.team1.code, other.team2.code))
    def __gt__(self, other):
        return self.utility() > other.utility()
    def __ge__(self, other):
        return self.utility() >= other.utility()
    def __lt__(self, other):
        return self.utility() < other.utility()
    def __le__(self, other):
        return self.utility() <= other.utility()

@dataclass(repr=False)
class Set:
    """ A set represents all matches played in a turn """
    matches: list

    def utility(self) -> float:
        """ compute principal's utility of the set """
        return sum(map(lambda x: x.utility(), self.matches))
    def __repr__(self):
        return repr(list(map(lambda x: (x.team1.name, x.team2.name), self.matches)))
    def __gt__(self, other):
        return self.utility() > other.utility()
    def __ge__(self, other):
        return self.utility() >= other.utility()
    def __lt__(self, other):
        return self.utility() < other.utility()
    def __le__(self, other):
        return self.utility() <= other.utility()

PREV_MATCHES = set()
def load_previous_matches(conn, turn):
    """ load all previous matches that have been played """
    global PREV_MATCHES # pylint: disable=W0603
    query = f"""
        SELECT result.turn, result.team1, team1.name, result.team2, team2.name
        FROM result
        INNER JOIN team as team1 ON result.team1 = team1.code
        INNER JOIN team as team2 ON result.team2 = team2.code
        WHERE turn < {turn}
    """
    PREV_MATCHES = {
        Match(turn, Team(id1, n1, 0), Team(id2, n2, 0))
        for (turn, id1, n1, id2, n2) in conn.execute(query).fetchall()
    }

def make_matches(turn, teams):
    """ compute the set that produces the most utility for the principal """
    def appear_once(matches) -> bool:
        teams = set()
        for match in matches:
            team1 = match.team1
            team2 = match.team2
            if team1 in teams or team2 in teams:
                return False
            teams.add(team1)
            teams.add(team2)
        return True
    p_matches = { Match(turn, *teams) for teams in it.combinations(teams, 2) }
    p_matches.difference_update(PREV_MATCHES)
    p_sets = [ 
        Set(matches)
        for matches in it.combinations(p_matches, int(len(teams)/2))
        if appear_once(matches)
    ]
    return max(p_sets).matches



if __name__ == "__main__":
    import argparse as ap
    def argparser() -> ap.ArgumentParser:
        """ Create argument parser """
        parser = ap.ArgumentParser(description = "Generate match pairs for next turn")
        parser.add_argument("turn", type=int)
        return parser

    def main(conn, turn):
        """ entry point """
        if turn == 1:
            # Le premier round est aléatoire
            import random # pylint: disable=C0415
            rteams =  [
                Team(*x, elo=BASE_ELO)
                for x in conn.execute("SELECT * FROM team").fetchall()
            ]
            random.shuffle(rteams)
            matches = [Match(turn, *rteams[i:i+2]) for i in range(0, len(rteams), 2)]

        else:
            # Les rounds d'après sont determinés par l'algorithme.
            # Pour cela on calcul l'état du monde (l'elo actuel des équipes)
            # avec les données de l'état d'avant.
            query = f"""
                SELECT result.team1, team1.name, result.elo1, result.points1,
                       result.team2, team2.name, result.elo2, result.points2 
                FROM result
                INNER JOIN team as team1 ON result.team1 = team1.code
                INNER JOIN team as team2 ON result.team2 = team2.code
                WHERE turn = {turn-1}
            """
            teams = []
            for match in conn.execute(query).fetchall():
                team1 = Team(*match[:3])
                score1 = match[3]

                team2 = Team(*match[4:7])
                score2 = match[7]

                # update to current state of the world
                t1_ed = K * (score1 - team1.expected_score(team2))
                team2.elo += K * (score2 - team2.expected_score(team1))
                team1.elo += t1_ed

                teams.append(team1)
                teams.append(team2)
            load_previous_matches(conn, turn)
            matches = make_matches(turn, teams)

        for match in matches:
            print(match.pretty())

    args = argparser().parse_args()
    with sql.connect("db.sqlite3") as db:
        main(db, args.turn)
